Current Score <input name="v_8" id="score" value="0" readonly size="4"/>
Highscore <input name="v_8" id="highscore" value="0" readonly size="4"/>
Games Started <input name="v_8" id="games" value="1" readonly size="4"/>
Games Won <input name="v_8" id="won" value="0" readonly size="4"/> <p>
Enjoyment 1  <input name="v_8" id="crm1" value="NA" readonly size="4"/> 
Enjoyment 2  <input name="v_8" id="crm2" value="NA" readonly size="4"/>
Enjoyment 3  <input name="v_8" id="crm3" value="NA" readonly size="4"/>
Enjoyment 4  <input name="v_8" id="crm4" value="NA" readonly size="4"/>
Enjoyment 5  <input name="v_8" id="crm5" value="NA" readonly size="4"/>
Enjoyment 6  <input name="v_8" id="crm6" value="NA" readonly size="4"/>
Enjoyment 7  <input name="v_8" id="crm7" value="NA" readonly size="4"/> 
    
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>Gamedev Canvas Workshop</title>
    <style>
    	* { padding: 0; margin: 0; }
    	canvas { background: #eee; display: block; margin: 0 auto; }
    </style>
</head>
<body>

<canvas id="myCanvas" width="480" height="320"></canvas>

<script>
  var canvas = document.getElementById("myCanvas");
  var ctx = canvas.getContext("2d");
  var x = canvas.width/2;
  var y = canvas.height-30;
  var origdx = 1.3;
  var dx = origdx;
  var dy = -1.3;
  var ballRadius = 10;
  // player paddle
  var paddleHeight = 10;
  var paddleWidth = 75;
  var paddleX = (canvas.width-paddleWidth)/2;
  // boolean to handle pressed keys
  var rightPressed = false;
  var leftPressed = false;
  // infos about bricks
  var brickRowCount = 3;
  var brickColumnCount = 5;
  var brickWidth = 75;
  var brickHeight = 20;
  var brickPadding = 10;
  var brickOffsetTop = 30;
  var brickOffsetLeft = 30;
  // score to be displayed
  var score = 0;
  var highscore = 0;
  var game =1;
  var status="run";
  var won=0;
  var feedback=0;
  var bricks = [];
  var crm = [];
  var framecountsincefeedback = 0
  for(c=0; c<brickColumnCount; c++) {
    bricks[c] = [];
    for(r=0; r<brickRowCount; r++) {
        bricks[c][r] = { x: 0, y: 0, status: 2 };
    }
  }
  function keyDownHandler(e) {
      if(e.keyCode == 39) {
          rightPressed = true;
      }
      else if(e.keyCode == 37) {
          leftPressed = true;
      }
  }
  function keyUpHandler(e) {
      if(e.keyCode == 39) {
          rightPressed = false;
      }
      else if(e.keyCode == 37) {
          leftPressed = false;
      }
  }
  function drawBall() {
    ctx.beginPath();
    ctx.arc(x, y, ballRadius, 0, Math.PI*2);
    ctx.fillStyle = "#0095DD";
    ctx.fill();
    ctx.closePath();
  }
  function drawScore() {
    ctx.font = "16px Arial";
    ctx.fillStyle = "#FF0000";
    ctx.fillText("Game: "+game+", Score: "+score+", Highscore: "+highscore, 8, 20);
  }
  function gameWin() {
    ctx.font = "16px Arial";
    ctx.fillStyle = "#FF0000";
    ctx.fillText("You Win! Secret Code: BRICKSAREGONE", 30, canvas.height/2);
  }
  function gameLose() {
    ctx.font = "16px Arial";
    ctx.fillStyle = "#FF0000";
    ctx.fillText("You Lost! Press the restart button below to start a new game.", 30, canvas.height/2);
  }
  function reset() {
      x = canvas.width/2;
      y = canvas.height-30;
      score = 0;
      game += 1;
      dx = Math.abs(origdx);
      dy = -Math.abs(dy);
      paddleX = (canvas.width-paddleWidth)/2;
      for(c=0; c<brickColumnCount; c++) {
        bricks[c] = [];
      for(r=0; r<brickRowCount; r++) {
        bricks[c][r] = { x: 0, y: 0, status: 2 };
      }
      status="run";
  }
  }
  function computeCollisionsWithWallsAndPaddle() {
    if (((x + ballRadius) >= canvas.width)) {
      dx=-origdx
    } else if (((x - ballRadius) <= 0)) {
      dx=origdx
    };
    if ((y - ballRadius) <= 0) {
      dy = -dy;
    }
    else if ((y + ballRadius) >= canvas.height) {
      if (x > paddleX && x < paddleX + paddleWidth) {
        dy = -dy;
        if (x < paddleX+(paddleWidth/3)){
          dx=dx-0.5;
        }
        else if (x > paddleX + ((2/3)*paddleWidth)){
          dx=dx+0.5;
        }
      }
      else {
        gameLose();
        status="stop"
      }
    }
  }
  function computeCollisionsWithBricks() {
    for (c = 0; c < brickColumnCount; c++) {
        for (r = 0; r < brickRowCount; r++) {
            var b = bricks[c][r];
            if (b.status > 0) {
              if (x > b.x && x < b.x + brickWidth && y > b.y && y < b.y + brickHeight) {
                  dy = -dy;
                  if (dx>0) {dx=origdx;} else {dx=-origdx;}
                  b.status -= 1;
                  if (b.status == 0)
                    score++;
                  if (score == brickRowCount * brickColumnCount) {
                    gameWin();
                    won+=1
                    status="game-end"
                  }
                  if (score>highscore){
                    highscore=score
                  }
              }
            }
        }
    }
  }
  function drawPaddle() {
    ctx.beginPath();
    ctx.rect(paddleX, canvas.height-paddleHeight, paddleWidth, paddleHeight);
    ctx.fillStyle = "#0095DD";
    ctx.fill();
    ctx.closePath();
    ///////////////random paddle moves
    /*
    if (Math.random()>.999 && paddleX < canvas.width-paddleWidth) {
      paddleX += Math.random()*100;
    }
    if (Math.random()>.999 && paddleX > 0) {
      paddleX -= Math.random()*100;
    }
    /////////////// COMMENT OUT UNTIL HERE
    */
    if(rightPressed && paddleX < canvas.width-paddleWidth) {
      paddleX += 7;
    }
    else if(leftPressed && paddleX > 0) {
      paddleX -= 7;
    }
    
  }

  function drawBricks() {
    for(c=0; c<brickColumnCount; c++) {
        for(r=0; r<brickRowCount; r++) {
          if (bricks[c][r].status > 0)
          {
            var brickX = (c * (brickWidth + brickPadding)) + brickOffsetLeft;
            var brickY = (r * (brickHeight + brickPadding)) + brickOffsetTop;
            bricks[c][r].x = brickX;
            bricks[c][r].y = brickY;
            ctx.beginPath();
            ctx.rect(brickX, brickY, brickWidth, brickHeight);
            if (bricks[c][r].status == 1) {
              ctx.fillStyle = "#0095DD";
            } else {
              ctx.fillStyle = "#0005DD";
            }
            ctx.fill();
            ctx.closePath();
          }
        }
    }
  }
  ////////////////////////////FEEDBACK/////////////////////////////
  function enjoyment () {
    ctx.font = "16px Arial";
    ctx.fillStyle = "#FF0000";
    ctx.fillText("Tell us how much you are enjoying the game right now?", 30, canvas.height/2);
    ctx.fillText("Press a button on the scale below from 1-7!", 30, (canvas.height/2+20));
  }
  function givefeedback(rating) {
    if (status=="feedback") {
      crm[feedback]=rating;
      document.getElementById('crm'+(feedback+1)).value=crm[feedback];
      if (crm.length < 7) {
        feedback += 1;
        framecountsincefeedback=0;
        status="run";
      } else {
        status='feedbackdone';
      }
    }
  }
  function feedbackDone() {
    ctx.font = "16px Arial";
    ctx.fillStyle = "#FF0000";
    ctx.fillText("Your are done! Secret Code: BRICKSAREGONE", 30, canvas.height/2);
  }
  ///////////////////////////RUNNING THE GAME//////////////////////////
  function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    // check if we are asking for feedback
    if (status=="game-end") {
      gameWin()
    } else if (status=="feedbackdone"){
      feedbackDone()
    } else if (framecountsincefeedback>3000){
      enjoyment()
      status="feedback"
    } else{
      //collision functions
      computeCollisionsWithWallsAndPaddle();
      computeCollisionsWithBricks();
      //run game
      if (status=="run"){
        /////////// RANDOM BALL MOVES
        /*
        if (Math.random()>.999 && x>30 && x<canvas.width-30) {
          if (Math.random()>.5){
            x += 20;
          } else {
            x-=20;
          }
        }
        if (Math.random()>.999 && y>canvas.height/2 && Y<canvas.height-30) {
          if (Math.random()>.5){
            y += 20;
          } else {
            y -=20;
          }
        }
        ///////////////COMMENT OUT UNTIL HERE!
        */
        x += dx;
        y += dy;
        drawBricks();
        drawPaddle();
        drawScore();
        drawBall();
        framecountsincefeedback+=1;
      }
    document.getElementById('score').value = score;
    document.getElementById('highscore').value = highscore;
    document.getElementById('games').value = game;
    document.getElementById('won').value = won;
    }

  }
  setInterval(draw, 10);
  document.addEventListener("keydown", keyDownHandler, false);
  document.addEventListener("keyup", keyUpHandler, false);
</script>
<center>
Use This Scale for in-game Questions <p>
 <a id="scale2" onclick="givefeedback(1)" style="background-color:#1E90FF; border: 1px solid blue"> 1 (Not at all)</a>
 <a id="scale2" onclick="givefeedback(2)" style="background-color:#1E90FF; border: 1px solid blue"> 2</a>
 <a id="scale3" onclick="givefeedback(3)" style="background-color:#1E90FF; border: 1px solid blue"> 3</a>
 <a id="scale4" onclick="givefeedback(4)" style="background-color:#1E90FF; border: 1px solid blue"> 4</a>
 <a id="scale5" onclick="givefeedback(5)" style="background-color:#1E90FF; border: 1px solid blue"> 5</a>
 <a id="scale6" onclick="givefeedback(6)" style="background-color:#1E90FF; border: 1px solid blue"> 6</a>
 <a id="scale7" onclick="givefeedback(7)" style="background-color:#1E90FF; border: 1px solid blue"> 7 (A lot) </a> <p><p>
 <a id="resetter" onclick="reset()" style="background-color:#1E90FF; border: 1px solid blue"> Reset and start new game.</a>
</center>
</body>
</html>

